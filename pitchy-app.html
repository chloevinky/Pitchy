<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitchy - Voice Pitch Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .upload-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background-color: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background-color: #f0f2ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .file-list {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .file-item {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            flex: 1;
            min-width: 250px;
        }

        .analysis-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .canvas-container {
            background: #f8f9ff;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            position: relative;
        }

        #pitchCanvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ebff 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .stat-title {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }

        .stat-unit {
            font-size: 0.9rem;
            color: #666;
            margin-left: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comparison-mode {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.8);
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Pitchy</h1>
            <p>Advanced Voice Pitch Analysis & Training Tool</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üé§</div>
                <h3>Upload MP3 Files</h3>
                <p>Drop your audio files here or click to browse</p>
                <p style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    Upload 1 file for analysis or 2 files for comparison
                </p>
                <input type="file" id="fileInput" class="file-input" accept=".mp3,.wav,.m4a" multiple>
            </div>
            
            <div class="file-list" id="fileList"></div>
            
            <div style="text-align: center;">
                <button class="btn" onclick="clearFiles()">Clear Files</button>
                <button class="btn" onclick="analyzeAudio()" id="analyzeBtn" disabled>Analyze Audio</button>
            </div>
        </div>

        <div class="analysis-section" id="analysisSection">
            <div class="loading" id="loadingDiv">
                <div class="spinner"></div>
                <p>Analyzing audio...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div id="resultsDiv" style="display: none;">
                <div class="controls">
                    <button class="btn" onclick="playPause()">‚ñ∂Ô∏è Play/Pause</button>
                    <button class="btn" onclick="exportData()">üìä Export Data</button>
                    <span id="timeDisplay">00:00 / 00:00</span>
                </div>

                <div class="canvas-container" id="canvasContainer">
                    <div class="legend" id="legend"></div>
                    <canvas id="pitchCanvas"></canvas>
                </div>

                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
    </div>

    <script>
        class PitchAnalyzer {
            constructor() {
                this.audioContext = null;
                this.audioFiles = [];
                this.analysisData = [];
                this.isPlaying = false;
                this.currentTime = 0;
                this.canvas = null;
                this.ctx = null;
                this.animationFrame = null;
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            }

            handleFileSelect(e) {
                this.handleFiles(e.target.files);
            }

            handleFiles(files) {
                this.audioFiles = Array.from(files).slice(0, 2); // Limit to 2 files
                this.displayFiles();
                document.getElementById('analyzeBtn').disabled = this.audioFiles.length === 0;
            }

            displayFiles() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                this.audioFiles.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <strong>File ${index + 1}:</strong> ${file.name}<br>
                        <small>Size: ${(file.size / 1024 / 1024).toFixed(2)} MB</small>
                    `;
                    fileList.appendChild(fileItem);
                });
            }

            async analyzeAudio() {
                document.getElementById('analysisSection').style.display = 'block';
                document.getElementById('loadingDiv').style.display = 'block';
                document.getElementById('resultsDiv').style.display = 'none';

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analysisData = [];

                    for (let i = 0; i < this.audioFiles.length; i++) {
                        const progress = ((i + 1) / this.audioFiles.length) * 100;
                        document.getElementById('progressFill').style.width = progress + '%';

                        const audioBuffer = await this.loadAudioFile(this.audioFiles[i]);
                        const pitchData = await this.extractPitchData(audioBuffer);
                        
                        this.analysisData.push({
                            filename: this.audioFiles[i].name,
                            buffer: audioBuffer,
                            pitchData: pitchData,
                            color: i === 0 ? '#667eea' : '#ff6b6b'
                        });
                    }

                    this.displayResults();
                } catch (error) {
                    console.error('Analysis failed:', error);
                    alert('Analysis failed. Please try again with different files.');
                }
            }

            async loadAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const audioBuffer = await this.audioContext.decodeAudioData(e.target.result);
                            resolve(audioBuffer);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            async extractPitchData(audioBuffer) {
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                const windowSize = 2048;
                const hopSize = 512;
                const pitchData = [];

                // Simple autocorrelation-based pitch detection
                for (let i = 0; i < channelData.length - windowSize; i += hopSize) {
                    const window = channelData.slice(i, i + windowSize);
                    const pitch = this.detectPitch(window, sampleRate);
                    const timeStamp = i / sampleRate;
                    
                    pitchData.push({
                        time: timeStamp,
                        frequency: pitch,
                        note: this.frequencyToNote(pitch)
                    });
                }

                return pitchData;
            }

            detectPitch(buffer, sampleRate) {
                const autocorrelation = new Array(buffer.length).fill(0);
                
                // Calculate autocorrelation
                for (let lag = 0; lag < buffer.length; lag++) {
                    let sum = 0;
                    for (let i = 0; i < buffer.length - lag; i++) {
                        sum += buffer[i] * buffer[i + lag];
                    }
                    autocorrelation[lag] = sum;
                }

                // Find the first peak after the initial peak
                let maxVal = Math.max(...autocorrelation);
                let threshold = maxVal * 0.3;
                
                for (let i = Math.floor(sampleRate / 800); i < Math.floor(sampleRate / 80); i++) {
                    if (autocorrelation[i] > threshold) {
                        // Refine using parabolic interpolation
                        if (i > 0 && i < autocorrelation.length - 1) {
                            const y1 = autocorrelation[i - 1];
                            const y2 = autocorrelation[i];
                            const y3 = autocorrelation[i + 1];
                            const x0 = (y3 - y1) / (2 * (2 * y2 - y1 - y3));
                            const refinedLag = i + x0;
                            return sampleRate / refinedLag;
                        }
                        return sampleRate / i;
                    }
                }
                
                return 0; // No pitch detected
            }

            frequencyToNote(frequency) {
                if (frequency < 80 || frequency > 800) return '';
                
                const A4 = 440;
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                const semitones = 12 * Math.log2(frequency / A4);
                const octave = Math.floor(4 + semitones / 12);
                const noteIndex = Math.round(semitones) % 12;
                
                return noteNames[noteIndex < 0 ? noteIndex + 12 : noteIndex] + octave;
            }

            displayResults() {
                document.getElementById('loadingDiv').style.display = 'none';
                document.getElementById('resultsDiv').style.display = 'block';

                this.setupCanvas();
                this.drawPitchGraph();
                this.displayStatistics();
                this.createLegend();

                if (this.analysisData.length > 1) {
                    document.getElementById('canvasContainer').classList.add('comparison-mode');
                }
            }

            setupCanvas() {
                this.canvas = document.getElementById('pitchCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            drawPitchGraph() {
                if (!this.ctx) return;

                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;

                // Clear canvas
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, width, height);

                if (this.analysisData.length === 0) return;

                // Find global min/max for scaling
                let minFreq = Infinity, maxFreq = 0, maxTime = 0;
                
                this.analysisData.forEach(data => {
                    data.pitchData.forEach(point => {
                        if (point.frequency > 0) {
                            minFreq = Math.min(minFreq, point.frequency);
                            maxFreq = Math.max(maxFreq, point.frequency);
                        }
                        maxTime = Math.max(maxTime, point.time);
                    });
                });

                // Add some padding
                const freqRange = maxFreq - minFreq;
                minFreq -= freqRange * 0.1;
                maxFreq += freqRange * 0.1;

                // Draw grid
                this.drawGrid(width, height, maxTime, minFreq, maxFreq);

                // Draw pitch lines
                this.analysisData.forEach(data => {
                    this.drawPitchLine(data, width, height, maxTime, minFreq, maxFreq);
                });
            }

            drawGrid(width, height, maxTime, minFreq, maxFreq) {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#666';

                const padding = 50;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;

                // Vertical grid lines (time)
                const timeSteps = 10;
                for (let i = 0; i <= timeSteps; i++) {
                    const x = padding + (i / timeSteps) * graphWidth;
                    const time = (i / timeSteps) * maxTime;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding);
                    this.ctx.lineTo(x, height - padding);
                    this.ctx.stroke();

                    this.ctx.fillText(time.toFixed(1) + 's', x - 15, height - 10);
                }

                // Horizontal grid lines (frequency)
                const freqSteps = 8;
                for (let i = 0; i <= freqSteps; i++) {
                    const y = padding + (i / freqSteps) * graphHeight;
                    const freq = maxFreq - (i / freqSteps) * (maxFreq - minFreq);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(width - padding, y);
                    this.ctx.stroke();

                    this.ctx.fillText(freq.toFixed(0) + 'Hz', 5, y + 5);
                }

                // Axes
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, height - padding);
                this.ctx.lineTo(width - padding, height - padding);
                this.ctx.stroke();
            }

            drawPitchLine(data, width, height, maxTime, minFreq, maxFreq) {
                const padding = 50;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;

                this.ctx.strokeStyle = data.color;
                this.ctx.lineWidth = 2;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.ctx.beginPath();
                let firstPoint = true;

                data.pitchData.forEach(point => {
                    if (point.frequency > 0) {
                        const x = padding + (point.time / maxTime) * graphWidth;
                        const y = padding + (1 - (point.frequency - minFreq) / (maxFreq - minFreq)) * graphHeight;

                        if (firstPoint) {
                            this.ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                });

                this.ctx.stroke();
            }

            createLegend() {
                const legend = document.getElementById('legend');
                legend.innerHTML = '';

                this.analysisData.forEach((data, index) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${data.color}"></div>
                        <span>${data.filename}</span>
                    `;
                    legend.appendChild(legendItem);
                });
            }

            displayStatistics() {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = '';

                this.analysisData.forEach((data, index) => {
                    const stats = this.calculateStatistics(data.pitchData);
                    const filePrefix = this.analysisData.length > 1 ? `File ${index + 1} - ` : '';

                    const statsCards = [
                        { title: `${filePrefix}Average Pitch`, value: stats.average.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Min Pitch`, value: stats.min.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Max Pitch`, value: stats.max.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Range`, value: (stats.max - stats.min).toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Stability`, value: (100 - stats.variance).toFixed(1), unit: '%' },
                        { title: `${filePrefix}Duration`, value: stats.duration.toFixed(1), unit: 's' }
                    ];

                    statsCards.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        card.innerHTML = `
                            <div class="stat-title">${stat.title}</div>
                            <div class="stat-value">${stat.value}<span class="stat-unit">${stat.unit}</span></div>
                        `;
                        statsGrid.appendChild(card);
                    });
                });

                // Add comparison stats if we have 2 files
                if (this.analysisData.length === 2) {
                    const comparison = this.compareFiles();
                    const comparisonCard = document.createElement('div');
                    comparisonCard.className = 'stat-card';
                    comparisonCard.style.gridColumn = '1 / -1';
                    comparisonCard.innerHTML = `
                        <div class="stat-title">Comparison Analysis</div>
                        <div style="font-size: 1rem; line-height: 1.5;">
                            Average Difference: ${comparison.avgDiff.toFixed(1)} Hz<br>
                            Correlation: ${comparison.correlation.toFixed(2)}<br>
                            Improvement: ${comparison.improvement > 0 ? '+' : ''}${comparison.improvement.toFixed(1)} Hz
                        </div>
                    `;
                    statsGrid.appendChild(comparisonCard);
                }
            }

            calculateStatistics(pitchData) {
                const validPitches = pitchData.filter(p => p.frequency > 0).map(p => p.frequency);
                
                if (validPitches.length === 0) {
                    return { average: 0, min: 0, max: 0, variance: 0, duration: 0 };
                }

                const average = validPitches.reduce((a, b) => a + b, 0) / validPitches.length;
                const min = Math.min(...validPitches);
                const max = Math.max(...validPitches);
                const variance = Math.sqrt(validPitches.reduce((a, b) => a + Math.pow(b - average, 2), 0) / validPitches.length) / average * 100;
                const duration = pitchData[pitchData.length - 1]?.time || 0;

                return { average, min, max, variance, duration };
            }

            compareFiles() {
                if (this.analysisData.length < 2) return null;

                const data1 = this.analysisData[0].pitchData.filter(p => p.frequency > 0);
                const data2 = this.analysisData[1].pitchData.filter(p => p.frequency > 0);

                const avg1 = data1.reduce((a, b) => a + b.frequency, 0) / data1.length;
                const avg2 = data2.reduce((a, b) => a + b.frequency, 0) / data2.length;

                // Simple correlation calculation
                const minLength = Math.min(data1.length, data2.length);
                let correlation = 0;
                if (minLength > 0) {
                    let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;
                    
                    for (let i = 0; i < minLength; i++) {
                        const x = data1[i].frequency;
                        const y = data2[i].frequency;
                        sumXY += x * y;
                        sumX += x;
                        sumY += y;
                        sumX2 += x * x;
                        sumY2 += y * y;
                    }
                    
                    const numerator = minLength * sumXY - sumX * sumY;
                    const denominator = Math.sqrt((minLength * sumX2 - sumX * sumX) * (minLength * sumY2 - sumY * sumY));
                    correlation = denominator !== 0 ? numerator / denominator : 0;
                }

                return {
                    avgDiff: Math.abs(avg1 - avg2),
                    correlation: correlation,
                    improvement: avg2 - avg1
                };
            }

            exportData() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    files: this.analysisData.map(data => ({
                        filename: data.filename,
                        statistics: this.calculateStatistics(data.pitchData),
                        pitchData: data.pitchData
                    }))
                };

                if (this.analysisData.length === 2) {
                    exportData.comparison = this.compareFiles();
                }

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pitchy-analysis-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Global functions
        let analyzer = new PitchAnalyzer();

        function clearFiles() {
            analyzer.audioFiles = [];
            analyzer.analysisData = [];
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analysisSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
        }

        function analyzeAudio() {
            analyzer.analyzeAudio();
        }

        function playPause() {
            // Simple implementation - in a full version, you'd implement actual audio playback
            alert('Audio playback feature would be implemented here with Web Audio API');
        }

        function exportData() {
            analyzer.exportData();
        }
    </script>
</body>
</html>