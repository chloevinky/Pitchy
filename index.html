<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Pitchy - Voice Training</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:Segoe UI, sans-serif;
      background:linear-gradient(135deg,#667eea,#764ba2);
      color:#333; display:flex; flex-direction:column; align-items:center; min-height:100vh;
    }
    header { text-align:center; margin:20px; color:#fff; }
    .container {
      width:90%; max-width:1200px; background:#fff; border-radius:10px;
      box-shadow:0 4px 6px rgba(0,0,0,0.1); overflow:hidden;
    }
    .controls {
      padding:20px; display:flex; flex-direction:column; align-items:center;
    }
    /* Accessible file input */
    #audioInput { margin-bottom:15px; }
    #audioInput::file-selector-button {
      background:#667eea; color:#fff; border:none; padding:10px 20px;
      border-radius:20px; cursor:pointer;
    }
    .btn {
      background:#667eea; color:#fff; border:none; padding:12px 24px;
      border-radius:25px; cursor:pointer; margin:5px;
    }
    .btn:hover { transform:translateY(-2px); }
    #loadingDiv { display:none; padding:10px; }
    #resultsDiv { display:none; }
    #canvasContainer {
      width:100%; height:500px; background:#f9f9f9; position:relative; margin:20px 0;
    }
    canvas { width:100%; height:100%; }
    /* Organized stats */
    .stats { display:flex; flex-direction:column; padding:0 20px 20px; }
    .stats-group { margin-bottom:20px; }
    .stats-group h3 {
      margin-bottom:10px; color:#667eea; font-size:1.2rem;
    }
    .stat-cards {
      display:grid; grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
      gap:10px;
    }
    .stat-card {
      background:#f1f1f1; border-radius:8px; padding:10px; text-align:center;
      font-size:0.9rem;
    }
    .legend {
      display:flex; justify-content:center; padding-bottom:20px;
    }
    .legend-item {
      display:flex; align-items:center; margin:0 10px;
    }
    .legend-color {
      width:16px; height:16px; margin-right:5px; border-radius:4px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Pitchy Voice Training</h1>
    <p>See your pitch against male, androgynous &amp; female bands.</p>
  </header>

  <div class="container">
    <div class="controls">
      <input
        type="file"
        id="audioInput"
        accept="audio/*"
        multiple
        aria-label="Select audio files"
        title="Select audio files"
      >
      <button class="btn" onclick="startAnalysis()" title="Analyze selected audio files">
        Analyze
      </button>
      <button class="btn" onclick="playPause()" title="Play or pause audio">
        Play/Pause
      </button>
      <button class="btn" onclick="exportData()" title="Export analysis as CSV">
        Export CSV
      </button>
      <div id="loadingDiv">Analyzing… please wait.</div>
    </div>

    <div id="resultsDiv">
      <div id="canvasContainer">
        <canvas id="pitchCanvas"></canvas>
      </div>
      <div class="stats" id="statsContainer"></div>
      <div class="legend" id="legendContainer"></div>
    </div>
  </div>

  <script>
    class PitchAnalyzer {
      constructor() {
        this.audioContext = new (window.AudioContext||window.webkitAudioContext)();
        this.audioFiles = [];
        this.analysisData = [];
      }

      addFiles(files) {
        this.audioFiles = Array.from(files);
      }

      async processFiles() {
        if (!this.audioFiles.length) return;
        document.getElementById('loadingDiv').style.display = 'block';
        this.analysisData = [];  // reset from previous runs

        for (let i=0; i<this.audioFiles.length; i++) {
          try {
            const buf = await this.loadAudioFile(this.audioFiles[i]);
            const pitchData = await this.extractPitchData(buf);
            this.analysisData.push({
              filename: this.audioFiles[i].name,
              pitchData,
              color: i===0?'#667eea':'#ff6b6b'
            });
          } catch {
            alert(`Failed to process ${this.audioFiles[i].name}`);
          }
        }

        document.getElementById('loadingDiv').style.display = 'none';
        this.displayResults();
      }

      loadAudioFile(file) {
        return new Promise((res, rej) => {
          const r = new FileReader();
          r.onload = async e => {
            try {
              const buf = await this.audioContext.decodeAudioData(e.target.result);
              res(buf);
            } catch(err){ rej(err); }
          };
          r.onerror = rej;
          r.readAsArrayBuffer(file);
        });
      }

      async extractPitchData(audioBuffer) {
        const data = audioBuffer.getChannelData(0);
        const sr = audioBuffer.sampleRate;
        const win=2048, hop=512;  // smoother curves
        const out = [];

        for (let i=0; i+win<data.length; i+=hop) {
          const slice = data.slice(i,i+win);
          // Hamming
          for (let j=0; j<slice.length; j++)
            slice[j] *= 0.54 - 0.46*Math.cos(2*Math.PI*j/(slice.length-1));

          const freq = this.detectPitchYIN(slice, sr);
          out.push({ time:i/sr, frequency:freq });
        }
        return out;
      }

      detectPitchYIN(buf, sr) {
        const thresh = 0.10;
        const minP = Math.floor(sr/800), maxP = Math.floor(sr/80);
        const d = new Float32Array(maxP+1), cmnd = new Float32Array(maxP+1);
        for (let t=1; t<=maxP; t++) {
          let sum=0;
          for (let j=0; j<buf.length-t; j++){
            const diff=buf[j]-buf[j+t];
            sum+=diff*diff;
          }
          d[t]=sum;
        }
        cmnd[0]=1;
        let run=0;
        for (let t=1; t<=maxP; t++){
          run+=d[t];
          cmnd[t]= run? d[t]*t/run : 1;
        }
        for (let t=minP; t<=maxP; t++){
          if (cmnd[t]<thresh){
            while (t+1<=maxP && cmnd[t+1]<cmnd[t]) t++;
            // parabolic refine
            const x0=cmnd[t-1], x1=cmnd[t], x2=cmnd[t+1];
            const a=(x0+x2-2*x1)/2, b=(x2-x0)/2;
            const tau = a? t + (-b/(2*a)) : t;
            return sr/tau;
          }
        }
        return 0;
      }

      displayResults() {
        document.getElementById('resultsDiv').style.display = 'block';
        this.setupCanvas();
        this.drawPitchGraph();
        this.displayStatistics();
        this.createLegend();
      }

      setupCanvas() {
        const c = document.getElementById('pitchCanvas');
        c.width = c.parentElement.clientWidth;
        c.height = c.parentElement.clientHeight;
        this.ctx = c.getContext('2d');
      }

      drawPitchGraph() {
        const c = document.getElementById('pitchCanvas');
        const W = c.width, H = c.height;
        const maxTime = Math.max(...this.analysisData.flatMap(d=>d.pitchData.map(p=>p.time)));
        // fixed axis to show full bands
        const minF = 50, maxF = 300;
        this.drawGrid(W,H,maxTime,minF,maxF);
        this.analysisData.forEach(d=> this.drawPitchLine(d,W,H,maxTime,minF,maxF));
      }

      drawGrid(W,H,T, minF, maxF) {
        const ctx = this.ctx, pad=60;
        const gw=W-2*pad, gh=H-2*pad;
        // background
        ctx.fillStyle='#fff'; ctx.fillRect(0,0,W,H);

        // gender zones
        [
          {lbl:'Male (85–155Hz)',min:85,max:155,col:'rgba(0,123,255,0.1)'},
          {lbl:'Andro (155–180Hz)',min:155,max:180,col:'rgba(123,0,255,0.1)'},
          {lbl:'Female (180–255Hz)',min:180,max:255,col:'rgba(255,0,123,0.1)'}
        ].forEach(z=>{
          const y1=pad+((maxF-z.max)/(maxF-minF))*gh;
          const y2=pad+((maxF-z.min)/(maxF-minF))*gh;
          ctx.fillStyle=z.col;
          ctx.fillRect(pad,y1,gw,y2-y1);
          ctx.fillStyle='#333';
          ctx.textAlign='left';
          ctx.fillText(z.lbl,pad+5,y1+15);
        });

        // axes & grid
        ctx.strokeStyle='#ccc'; ctx.lineWidth=1; ctx.font='12px Arial'; ctx.fillStyle='#555';
        // time
        for(let i=0;i<=5;i++){
          const x=pad+(i/5)*gw;
          ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,H-pad); ctx.stroke();
          ctx.textAlign='center'; ctx.fillText((T*(i/5)).toFixed(1)+'s',x,H-pad+20);
        }
        // freq
        for(let i=0;i<=5;i++){
          const y=pad+(i/5)*gh;
          const f=maxF-(i/5)*(maxF-minF);
          ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(W-pad,y); ctx.stroke();
          ctx.textAlign='right'; ctx.fillText(f.toFixed(0)+'Hz',pad-10,y+4);
        }
        // main axes thicker
        ctx.strokeStyle='#333'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(pad,pad); ctx.lineTo(pad,H-pad); ctx.stroke();
      }

      drawPitchLine(data,W,H,T,minF,maxF) {
        const ctx=this.ctx, pad=60, gw=W-2*pad, gh=H-2*pad;
        ctx.strokeStyle=data.color; ctx.lineWidth=2; ctx.beginPath();
        data.pitchData.forEach((p,i)=>{
          if(p.frequency>0){
            const x=pad+(p.time/T)*gw;
            const y=pad+((maxF-p.frequency)/(maxF-minF))*gh;
            i? ctx.lineTo(x,y) : ctx.moveTo(x,y);
          }
        });
        ctx.stroke();
      }

      calculateStatistics(pd) {
        const freqs=pd.map(p=>p.frequency).filter(f=>f>0);
        const sum=freqs.reduce((a,b)=>a+b,0), avg=freqs.length?sum/freqs.length:0;
        const mn=freqs.length?Math.min(...freqs):0, mx=freqs.length?Math.max(...freqs):0;
        return { average:avg, min:mn, max:mx };
      }

      displayStatistics() {
        const c=document.getElementById('statsContainer');
        c.innerHTML='';
        this.analysisData.forEach(d=>{
          const s=this.calculateStatistics(d.pitchData);
          const grp=document.createElement('div');
          grp.className='stats-group';
          const h3=document.createElement('h3');
          h3.textContent=d.filename;
          grp.appendChild(h3);
          const cards=document.createElement('div');
          cards.className='stat-cards';
          [
            {t:'Average Pitch',v:s.average.toFixed(1)+' Hz'},
            {t:'Min Pitch',v:s.min.toFixed(1)+' Hz'},
            {t:'Max Pitch',v:s.max.toFixed(1)+' Hz'},
            {t:'Range',v:(s.max-s.min).toFixed(1)+' Hz'}
          ].forEach(m=>{
            const div=document.createElement('div');
            div.className='stat-card';
            div.innerHTML=`<strong>${m.t}</strong><br>${m.v}`;
            cards.appendChild(div);
          });
          grp.appendChild(cards);
          c.appendChild(grp);
        });
      }

      createLegend() {
        const lc=document.getElementById('legendContainer');
        lc.innerHTML='';
        this.analysisData.forEach(d=>{
          const item=document.createElement('div');
          item.className='legend-item';
          item.innerHTML=`<div class="legend-color" style="background:${d.color}"></div>${d.filename}`;
          lc.appendChild(item);
        });
      }

      exportData() {
        let csv='filename,time,frequency\n';
        this.analysisData.forEach(d=>{
          d.pitchData.forEach(p=>{
            csv+=`${d.filename},${p.time.toFixed(3)},${p.frequency.toFixed(2)}\n`;
          });
        });
        const blob=new Blob([csv],{type:'text/csv'});
        const url=URL.createObjectURL(blob);
        const a=document.createElement('a');
        a.href=url; a.download='pitch_analysis.csv';
        document.body.appendChild(a); a.click(); a.remove();
      }
    }

    const analyzer = new PitchAnalyzer();
    document.getElementById('audioInput').addEventListener('change', e=>{
      analyzer.addFiles(e.target.files);
    });
    function startAnalysis(){ analyzer.processFiles(); }
    function playPause(){
      alert('Audio playback would be implemented here.');
    }
    function exportData(){ analyzer.exportData(); }
  </script>
</body>
</html>
