<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitchy - Voice Pitch Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .upload-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background-color: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background-color: #f0f2ff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 15px;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .file-list {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .file-item {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            flex: 1;
            min-width: 250px;
        }

        .analysis-section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .canvas-container {
            background: #f8f9ff;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            position: relative;
        }

        #pitchCanvas {
            width: 100%;
            height: 400px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ebff 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .stat-title {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
        }

        .stat-unit {
            font-size: 0.9rem;
            color: #666;
            margin-left: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .comparison-mode {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.8);
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéµ Pitchy</h1>
            <p>Advanced Voice Pitch Analysis & Training Tool</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üé§</div>
                <h3>Upload MP3 Files</h3>
                <p>Drop your audio files here or click to browse</p>
                <p style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    Upload 1 file for analysis or 2 files for comparison
                </p>
                <input type="file" id="fileInput" class="file-input" accept=".mp3,.wav,.m4a" multiple>
            </div>
            
            <div class="file-list" id="fileList"></div>
            
            <div style="text-align: center;">
                <button class="btn" onclick="clearFiles()">Clear Files</button>
                <button class="btn" onclick="analyzeAudio()" id="analyzeBtn" disabled>Analyze Audio</button>
            </div>
        </div>

        <div class="analysis-section" id="analysisSection">
            <div class="loading" id="loadingDiv">
                <div class="spinner"></div>
                <p>Analyzing audio...</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div id="resultsDiv" style="display: none;">
                <div class="controls">
                    <button class="btn" onclick="playPause()">‚ñ∂Ô∏è Play/Pause</button>
                    <button class="btn" onclick="exportData()">üìä Export Data</button>
                    <span id="timeDisplay">00:00 / 00:00</span>
                </div>

                <div class="canvas-container" id="canvasContainer">
                    <div class="legend" id="legend"></div>
                    <canvas id="pitchCanvas"></canvas>
                </div>

                <div class="stats-grid" id="statsGrid"></div>
            </div>
        </div>
    </div>

    <script>
        class PitchAnalyzer {
            constructor() {
                this.audioContext = null;
                this.audioFiles = [];
                this.analysisData = [];
                this.isPlaying = false;
                this.currentTime = 0;
                this.canvas = null;
                this.ctx = null;
                this.animationFrame = null;
                
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.add('dragover');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('uploadArea').classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files);
            }

            handleFileSelect(e) {
                this.handleFiles(e.target.files);
            }

            handleFiles(files) {
                this.audioFiles = Array.from(files).slice(0, 2); // Limit to 2 files
                this.displayFiles();
                document.getElementById('analyzeBtn').disabled = this.audioFiles.length === 0;
            }

            displayFiles() {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                this.audioFiles.forEach((file, index) => {
                    const fileItem = document.createElement('div');
                    fileItem.className = 'file-item';
                    fileItem.innerHTML = `
                        <strong>File ${index + 1}:</strong> ${file.name}<br>
                        <small>Size: ${(file.size / 1024 / 1024).toFixed(2)} MB</small>
                    `;
                    fileList.appendChild(fileItem);
                });
            }

            async analyzeAudio() {
                document.getElementById('analysisSection').style.display = 'block';
                document.getElementById('loadingDiv').style.display = 'block';
                document.getElementById('resultsDiv').style.display = 'none';

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analysisData = [];

                    for (let i = 0; i < this.audioFiles.length; i++) {
                        const progress = ((i + 1) / this.audioFiles.length) * 100;
                        document.getElementById('progressFill').style.width = progress + '%';

                        const audioBuffer = await this.loadAudioFile(this.audioFiles[i]);
                        const pitchData = await this.extractPitchData(audioBuffer);
                        
                        this.analysisData.push({
                            filename: this.audioFiles[i].name,
                            buffer: audioBuffer,
                            pitchData: pitchData,
                            color: i === 0 ? '#667eea' : '#ff6b6b'
                        });
                    }

                    this.displayResults();
                } catch (error) {
                    console.error('Analysis failed:', error);
                    alert('Analysis failed. Please try again with different files.');
                }
            }

            async loadAudioFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const audioBuffer = await this.audioContext.decodeAudioData(e.target.result);
                            resolve(audioBuffer);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            async extractPitchData(audioBuffer) {
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                const windowSize = 4096; // Larger window for better frequency resolution
                const hopSize = 1024;
                const pitchData = [];

                // Pre-emphasis filter to enhance higher frequencies
                const preEmphasis = 0.97;
                const filtered = new Float32Array(channelData.length);
                filtered[0] = channelData[0];
                for (let i = 1; i < channelData.length; i++) {
                    filtered[i] = channelData[i] - preEmphasis * channelData[i - 1];
                }

                for (let i = 0; i < filtered.length - windowSize; i += hopSize) {
                    const window = filtered.slice(i, i + windowSize);
                    
                    // Apply Hamming window
                    for (let j = 0; j < window.length; j++) {
                        window[j] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * j / (window.length - 1));
                    }
                    
                    const pitch = this.detectPitchYIN(window, sampleRate);
                    const timeStamp = i / sampleRate;
                    
                    pitchData.push({
                        time: timeStamp,
                        frequency: pitch,
                        note: this.frequencyToNote(pitch)
                    });
                }

                return pitchData;
            }

            detectPitchYIN(buffer, sampleRate) {
                const threshold = 0.15;
                const minPeriod = Math.floor(sampleRate / 800); // 800 Hz max
                const maxPeriod = Math.floor(sampleRate / 80);  // 80 Hz min
                
                if (maxPeriod >= buffer.length) return 0;

                // Calculate difference function
                const d = new Float32Array(maxPeriod + 1);
                for (let tau = minPeriod; tau <= maxPeriod; tau++) {
                    let sum = 0;
                    for (let i = 0; i < buffer.length - tau; i++) {
                        const diff = buffer[i] - buffer[i + tau];
                        sum += diff * diff;
                    }
                    d[tau] = sum;
                }

                // Calculate cumulative mean normalized difference
                const cmnd = new Float32Array(maxPeriod + 1);
                cmnd[0] = 1;
                let runningSum = 0;
                
                for (let tau = 1; tau <= maxPeriod; tau++) {
                    runningSum += d[tau];
                    if (runningSum === 0) {
                        cmnd[tau] = 1;
                    } else {
                        cmnd[tau] = d[tau] * tau / runningSum;
                    }
                }

                // Find the first minimum below threshold
                for (let tau = minPeriod; tau <= maxPeriod; tau++) {
                    if (cmnd[tau] < threshold) {
                        // Look for local minimum
                        while (tau + 1 <= maxPeriod && cmnd[tau + 1] < cmnd[tau]) {
                            tau++;
                        }
                        
                        // Parabolic interpolation for better accuracy
                        if (tau > 0 && tau < maxPeriod) {
                            const s0 = cmnd[tau - 1];
                            const s1 = cmnd[tau];
                            const s2 = cmnd[tau + 1];
                            
                            const a = (s0 - 2 * s1 + s2) / 2;
                            const b = (s2 - s0) / 2;
                            
                            if (a !== 0) {
                                const tauFraction = -b / (2 * a);
                                if (Math.abs(tauFraction) < 1) {
                                    return sampleRate / (tau + tauFraction);
                                }
                            }
                        }
                        
                        return sampleRate / tau;
                    }
                }

                return 0; // No pitch detected
            }

            frequencyToNote(frequency) {
                if (frequency < 80 || frequency > 800 || frequency === 0) return '';
                
                const A4 = 440;
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                
                const semitones = 12 * Math.log2(frequency / A4);
                const octave = Math.floor(4 + semitones / 12);
                const noteIndex = Math.round(semitones) % 12;
                const finalIndex = noteIndex < 0 ? noteIndex + 12 : noteIndex;
                
                return noteNames[finalIndex] + octave;
            }

            displayResults() {
                document.getElementById('loadingDiv').style.display = 'none';
                document.getElementById('resultsDiv').style.display = 'block';

                this.setupCanvas();
                this.drawPitchGraph();
                this.displayStatistics();
                this.createLegend();

                if (this.analysisData.length > 1) {
                    document.getElementById('canvasContainer').classList.add('comparison-mode');
                }
            }

            setupCanvas() {
                this.canvas = document.getElementById('pitchCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }

            drawPitchGraph() {
                if (!this.ctx) return;

                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;

                // Clear canvas
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, width, height);

                if (this.analysisData.length === 0) return;

                // Find global min/max for scaling, filtering out zero values
                let minFreq = Infinity, maxFreq = 0, maxTime = 0;
                
                this.analysisData.forEach(data => {
                    data.pitchData.forEach(point => {
                        if (point.frequency > 0) {
                            minFreq = Math.min(minFreq, point.frequency);
                            maxFreq = Math.max(maxFreq, point.frequency);
                        }
                        maxTime = Math.max(maxTime, point.time);
                    });
                });

                // Set reasonable defaults if no valid pitches found
                if (minFreq === Infinity) {
                    minFreq = 80;
                    maxFreq = 400;
                }

                // Add some padding
                const freqRange = maxFreq - minFreq;
                minFreq = Math.max(80, minFreq - freqRange * 0.1);
                maxFreq = Math.min(800, maxFreq + freqRange * 0.1);

                // Draw grid
                this.drawGrid(width, height, maxTime, minFreq, maxFreq);

                // Draw pitch lines
                this.analysisData.forEach(data => {
                    this.drawPitchLine(data, width, height, maxTime, minFreq, maxFreq);
                });
            }

            drawGrid(width, height, maxTime, minFreq, maxFreq) {
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                this.ctx.font = '12px Arial';
                this.ctx.fillStyle = '#666';

                const padding = 60;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;

                // Vertical grid lines (time)
                const timeSteps = 10;
                for (let i = 0; i <= timeSteps; i++) {
                    const x = padding + (i / timeSteps) * graphWidth;
                    const time = (i / timeSteps) * maxTime;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, padding);
                    this.ctx.lineTo(x, height - padding);
                    this.ctx.stroke();

                    this.ctx.fillText(time.toFixed(1) + 's', x - 15, height - 10);
                }

                // Horizontal grid lines (frequency)
                const freqSteps = 8;
                for (let i = 0; i <= freqSteps; i++) {
                    const y = padding + (i / freqSteps) * graphHeight;
                    const freq = maxFreq - (i / freqSteps) * (maxFreq - minFreq);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(width - padding, y);
                    this.ctx.stroke();

                    this.ctx.fillText(freq.toFixed(0) + 'Hz', 5, y + 5);
                }

                // Axes
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(padding, height - padding);
                this.ctx.lineTo(width - padding, height - padding);
                this.ctx.stroke();

                // Labels
                this.ctx.fillStyle = '#333';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillText('Frequency (Hz)', 5, 30);
                this.ctx.fillText('Time (seconds)', width - 120, height - 10);
            }

            drawPitchLine(data, width, height, maxTime, minFreq, maxFreq) {
                const padding = 60;
                const graphWidth = width - padding * 2;
                const graphHeight = height - padding * 2;

                this.ctx.strokeStyle = data.color;
                this.ctx.lineWidth = 2;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';

                this.ctx.beginPath();
                let hasStarted = false;

                data.pitchData.forEach(point => {
                    if (point.frequency > 0 && point.frequency >= minFreq && point.frequency <= maxFreq) {
                        const x = padding + (point.time / maxTime) * graphWidth;
                        const y = padding + (1 - (point.frequency - minFreq) / (maxFreq - minFreq)) * graphHeight;

                        if (!hasStarted) {
                            this.ctx.moveTo(x, y);
                            hasStarted = true;
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    } else if (hasStarted) {
                        // Break the line when there's no pitch
                        this.ctx.stroke();
                        this.ctx.beginPath();
                        hasStarted = false;
                    }
                });

                if (hasStarted) {
                    this.ctx.stroke();
                }
            }

            createLegend() {
                const legend = document.getElementById('legend');
                legend.innerHTML = '';

                this.analysisData.forEach((data, index) => {
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background-color: ${data.color}"></div>
                        <span>${data.filename}</span>
                    `;
                    legend.appendChild(legendItem);
                });
            }

            displayStatistics() {
                const statsGrid = document.getElementById('statsGrid');
                statsGrid.innerHTML = '';

                this.analysisData.forEach((data, index) => {
                    const stats = this.calculateStatistics(data.pitchData);
                    const filePrefix = this.analysisData.length > 1 ? `File ${index + 1} - ` : '';

                    const statsCards = [
                        { title: `${filePrefix}Average Pitch`, value: stats.average.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Min Pitch`, value: stats.min.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Max Pitch`, value: stats.max.toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Range`, value: (stats.max - stats.min).toFixed(1), unit: 'Hz' },
                        { title: `${filePrefix}Stability`, value: stats.stability.toFixed(1), unit: '%' },
                        { title: `${filePrefix}Duration`, value: stats.duration.toFixed(1), unit: 's' }
                    ];

                    statsCards.forEach(stat => {
                        const card = document.createElement('div');
                        card.className = 'stat-card';
                        card.innerHTML = `
                            <div class="stat-title">${stat.title}</div>
                            <div class="stat-value">${stat.value}<span class="stat-unit">${stat.unit}</span></div>
                        `;
                        statsGrid.appendChild(card);
                    });
                });

                // Add comparison stats if we have 2 files
                if (this.analysisData.length === 2) {
                    const comparison = this.compareFiles();
                    const comparisonCard = document.createElement('div');
                    comparisonCard.className = 'stat-card';
                    comparisonCard.style.gridColumn = '1 / -1';
                    comparisonCard.innerHTML = `
                        <div class="stat-title">Comparison Analysis</div>
                        <div style="font-size: 1rem; line-height: 1.5;">
                            Average Difference: ${comparison.avgDiff.toFixed(1)} Hz<br>
                            Correlation: ${comparison.correlation.toFixed(2)}<br>
                            Improvement: ${comparison.improvement > 0 ? '+' : ''}${comparison.improvement.toFixed(1)} Hz
                        </div>
                    `;
                    statsGrid.appendChild(comparisonCard);
                }
            }

            calculateStatistics(pitchData) {
                const validPitches = pitchData.filter(p => p.frequency > 0 && p.frequency >= 80 && p.frequency <= 800).map(p => p.frequency);
                
                if (validPitches.length === 0) {
                    return { average: 0, min: 0, max: 0, stability: 0, duration: 0 };
                }

                const average = validPitches.reduce((a, b) => a + b, 0) / validPitches.length;
                const min = Math.min(...validPitches);
                const max = Math.max(...validPitches);
                
                // Calculate standard deviation
                const variance = validPitches.reduce((a, b) => a + Math.pow(b - average, 2), 0) / validPitches.length;
                const standardDeviation = Math.sqrt(variance);
                
                // Stability as percentage (lower deviation = higher stability)
                const stability = Math.max(0, 100 - (standardDeviation / average * 100));
                
                const duration = pitchData[pitchData.length - 1]?.time || 0;

                return { average, min, max, stability, duration };
            }

            compareFiles() {
                if (this.analysisData.length < 2) return null;

                const data1 = this.analysisData[0].pitchData.filter(p => p.frequency > 0 && p.frequency >= 80 && p.frequency <= 800);
                const data2 = this.analysisData[1].pitchData.filter(p => p.frequency > 0 && p.frequency >= 80 && p.frequency <= 800);

                if (data1.length === 0 || data2.length === 0) {
                    return { avgDiff: 0, correlation: 0, improvement: 0 };
                }

                const avg1 = data1.reduce((a, b) => a + b.frequency, 0) / data1.length;
                const avg2 = data2.reduce((a, b) => a + b.frequency, 0) / data2.length;

                // Simple correlation calculation using overlapping time periods
                const minLength = Math.min(data1.length, data2.length);
                let correlation = 0;
                if (minLength > 1) {
                    let sumXY = 0, sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0;
                    
                    for (let i = 0; i < minLength; i++) {
                        const x = data1[i].frequency;
                        const y = data2[i].frequency;
                        sumXY += x * y;
                        sumX += x;
                        sumY += y;
                        sumX2 += x * x;
                        sumY2 += y * y;
                    }
                    
                    const numerator = minLength * sumXY - sumX * sumY;
                    const denominator = Math.sqrt((minLength * sumX2 - sumX * sumX) * (minLength * sumY2 - sumY * sumY));
                    correlation = denominator !== 0 ? numerator / denominator : 0;
                }

                return {
                    avgDiff: Math.abs(avg1 - avg2),
                    correlation: correlation,
                    improvement: avg2 - avg1
                };
            }

            exportData() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    files: this.analysisData.map(data => ({
                        filename: data.filename,
                        statistics: this.calculateStatistics(data.pitchData),
                        pitchData: data.pitchData
                    }))
                };

                if (this.analysisData.length === 2) {
                    exportData.comparison = this.compareFiles();
                }

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pitchy-analysis-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Global functions
        let analyzer = new PitchAnalyzer();

        function clearFiles() {
            analyzer.audioFiles = [];
            analyzer.analysisData = [];
            document.getElementById('fileList').innerHTML = '';
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analysisSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
        }

        function analyzeAudio() {
            analyzer.analyzeAudio();
        }

        function playPause() {
            // Simple implementation - in a full version, you'd implement actual audio playback
            alert('Audio playback feature would be implemented here with Web Audio API');
        }

        function exportData() {
            analyzer.exportData();
        }
    </script>
</body>
</html>
